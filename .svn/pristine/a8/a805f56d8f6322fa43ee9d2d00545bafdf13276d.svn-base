import { Component, OnInit } from '@angular/core';
import { NgbAccordionConfig } from '@ng-bootstrap/ng-bootstrap';
import { NavController } from '@ionic/angular';
import { point, distance } from '@turf/turf';


import { ApiServiceService } from '../../../services/api-service.service';

import {
  STEP_ITEMS, CITIES,
  museumOptions, entertainmentOptions, foodOptions, buildingsOptions,
  outdoorsAndRecreationOptions, shoppingOptions, performingArtsOptions, nightlifeOptions
} from './constants';


// tour draft response. TODO: delete file when done
import { response2 } from './tourdraft'

export interface PreferenceSelections {
  selections: Array<String>;
}

interface Preference {
  [key: string]: Array<String>
}


@Component({
  selector: 'app-create-tour',
  templateUrl: './create-tour.component.html',
  styleUrls: ['./create-tour.component.scss'],
})
export class CreateTourComponent implements OnInit {

  totalSelected: number = 0;
  minSelectCount: number = 4;
  maxSelectCount: number = 8;
  disableButton: boolean = true;
  city: string = '';
  showWarning: boolean = false;
  tourItenaryGenerated: boolean = false;

  selectedDraftItems: Array<any> = [];
  selectedDraftItemsIds: Array<any> = [];
  tourItenary: Array<any> = []

  formContent: any;
  formData: any;
  preferences: Array<Preference>;
  activeStepIndex: number;
  // Use this to check API response for generating draft
  itenarnaryDraftGenerated: boolean = true;
  // itenarnaryDraft: any = {};
  itenarnaryDraft: any = response2;
  itenarnaryCreated: boolean = false;
  cities: any = CITIES;
  // lng and lat
  startLocation: Array<any> = [9.914066791534424, 53.54406887989486]


  // Preference options
  museumOptions: any = museumOptions;
  entertainmentOptions: any = entertainmentOptions;
  foodOptions: any = foodOptions;
  outdoorsAndRecreationOptions: any = outdoorsAndRecreationOptions;
  shoppingOptions: any = shoppingOptions;
  buildingsOptions: any = buildingsOptions;
  performingArtsOptions: any = performingArtsOptions;
  nightlifeOptions: any = nightlifeOptions;

  constructor(
    config: NgbAccordionConfig,
    private apiService: ApiServiceService,
  ) {
    config.closeOthers = true;
  }

  ngOnInit() {
    this.formContent = STEP_ITEMS;
    this.formData = {};
  }

  planTour() {
    console.log('lets go!');
  }

  addItemToFormData(item, category) {
    if (this.formData[category] && this.formData[category].indexOf(item) == -1) {
      this.formData[category].push(item)
    } else {
      this.formData[category] = [item]
    }
  }

  removeItemToFormData(item, category) {
    if (this.formData[category] && this.formData[category].indexOf(item) > -1) {
      this.formData[category].splice(this.formData[category].indexOf(item), 1)
    }
  }


  addItemToInterests(item) {
    if (this.formData['interests'] && this.formData['interests'].indexOf(item) == -1) {
      this.formData['interests'].push(item)
    } else {
      this.formData['interests'] = [item]
    }
  }

  removeItemFromInterests(item) {
    if (this.formData['interests'] && this.formData['interests'].indexOf(item) > -1) {
      this.formData['interests'].splice(this.formData['interests'].indexOf(item), 1)
    }
  }

  updateButtonStatus() {
    this.totalSelected < this.minSelectCount || this.totalSelected > this.maxSelectCount ?
      this.disableButton = true : this.disableButton = false;
  }

  updateTotalSelected(item, category) {
    if (item.selected) {
      this.totalSelected++
      this.addItemToFormData(item.value, category);
      this.addItemToInterests(item.value);
    } else {
      this.totalSelected--;
      this.removeItemToFormData(item.value, category);
      this.removeItemFromInterests(item.value);
    }

    console.log(this.formData, 'formData <> las las')
    this.updateButtonStatus();
  }

  submitPreference(formData) {
    if (!this.city) {
      this.showWarning = true;
    } else {
      this.showWarning = false;
      console.log(formData, 'formData in submitPreference');
      this.itenarnaryDraftGenerated = true;
      // this.apiService.createTour2({city: this.city, interests: formData.interests})
      //   .then(response => {
      //     this.itenarnaryDraftGenerated = true;
      //     this.itenarnaryDraft = response;
      //     console.log(response, 'API response')
      //   })
      //   .catch(error => {
      //     console.log(error, 'API error')
      //   })
    }
  }

  getImageUrl(photo) {
    return `${photo.prefix}${photo.width}x${photo.height}${photo.suffix}`
  }

  getFormattedAddress(formattedAddress) {
    return formattedAddress.join(', ')
  }

  updateSelectedDraftItems(event, item) {
    const itemIndex = this.selectedDraftItems.map((item) => item.venue.id).indexOf(item.venue.id);

    if (event.target.checked) {
      this.selectedDraftItems.push(item)
    } else {
      this.selectedDraftItems.splice(itemIndex, 1);
    }

    // for item log
    console.log(item, 'this is the selected item');
  }

  createTour() {
    // TODO:
    // only create tour if selected items is more than five
    // User should not be able to selected more than 10 items

  }

  sortByDistance() {
    return this.selectedDraftItems.sort((a, b) => {
      a.distance = distance(point(this.startLocation), point([a.venue.location.lng, a.venue.location.lat]), { units: 'kilometers' })
      b.distance = distance(point(this.startLocation), point([b.venue.location.lng, b.venue.location.lat]), { units: 'kilometers' })

      return a.distance - b.distance
    })

  }

  createTourItinerary() {
    this.tourItenaryGenerated = true;
    this.itenarnaryDraftGenerated = false;

    this.tourItenary = this.sortByDistance();

    const newItems = this.calculateDistanceBetweenVenues(this.tourItenary)
    console.log(newItems, 'after computation <> newItems === what is here')
  }

  calculateDistanceBetweenVenues(items) {
    console.log("calculateDistanceBetweenVenues <> called");

    return items.map((item, index) => {
      if (index != 0) {
        // round off the distance to the nearest decimal place
        item.newDistance = Math.round(distance(
          point([items[index - 1].venue.location.lng, items[index - 1].venue.location.lat]),
          point([item.venue.location.lng, item.venue.location.lat]),
          { units: 'kilometers' }
        ) * 10 ) / 10
      } else {
        item.newDistance = Math.round(distance(
          point(this.startLocation),
          point([item.venue.location.lng, item.venue.location.lat]),
          { units: 'kilometers' }
        ) * 10 ) / 10
      }
  
      return item;
    })
  }

}
